#include "encoding.h"
#include "xe/string.h"

using namespace xurl;

static xe_string base64_charsets[] = {
	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
};

static const byte base64_decode[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x3e, 0x00, 0x3f,
	0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
	0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x00, 0x00, 0x00, 0x00, 0x3f,
	0x00, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
	0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const byte hex_decode[] = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

static xe_string& xe_base64_getcharset(xe_base64_encoding encoding){
	switch(encoding){
		case XE_BASE64:
		case XE_BASE64_PAD:
			return base64_charsets[0];
		case XE_BASE64_URL:
		case XE_BASE64_URL_PAD:
			return base64_charsets[1];
	}

	return base64_charsets[0];
}

size_t xurl::xe_base64_encoded_length(xe_base64_encoding encoding, size_t length){
	size_t lens[] = {0, 2, 3};

	switch(encoding){
		case XE_BASE64:
		case XE_BASE64_URL:
			return (length / 3) * 4 + lens[length % 3];
		case XE_BASE64_PAD:
		case XE_BASE64_URL_PAD:
			return ((length + 2) / 3) * 4;
	}

	return 0;
}

size_t xurl::xe_base64_decoded_length(xe_base64_encoding encoding, xe_cptr vin, size_t length){
	size_t lens[] = {0, 1, 1, 2, 3};
	xe_cbptr in = (xe_cbptr)vin;

	if(encoding == XE_BASE64_PAD || encoding == XE_BASE64_URL_PAD){
		while(length && in[length - 1] == '=')
			length--;
	}

	return (length / 4) * 3 + lens[length % 4];
}

size_t xurl::xe_base64_encode(xe_base64_encoding encoding, xe_ptr vout, size_t out_len, xe_cptr vin, size_t in_len){
	xe_string& set = xe_base64_getcharset(encoding);
	xe_bptr out = (xe_bptr)vout;
	xe_cbptr in = (xe_cbptr)vin;
	xe_bptr start = out;

	while(in_len >= 3){
		out[0] = set[in[0] >> 2];
		out[1] = set[((in[0] & 0x03) << 4) | (in[1] >> 4)];
		out[2] = set[((in[1] & 0x0f) << 2) | (in[2] >> 6)];
		out[3] = set[in[2] & 0x3f];

		in += 3;
		in_len -= 3;
		out += 4;
		out_len -= 4;
	}

	if(in_len == 1){
		out[0] = set[in[0] >> 2];
		out[1] = set[(in[0] & 0x03) << 4];
		out += 2;
		out_len -= 2;

		if(encoding == XE_BASE64_PAD || encoding == XE_BASE64_URL_PAD){
			out[0] = '=';
			out[1] = '=';
			out += 2;
			out_len -= 2;
		}
	}else if(in_len == 2){
		out[0] = set[in[0] >> 2];
		out[1] = set[((in[0] & 0x03) << 4) | (in[1] >> 4)];
		out[2] = set[(in[1] & 0x0f) << 2];
		out += 3;
		out_len -= 3;

		if(encoding == XE_BASE64_PAD || encoding == XE_BASE64_URL_PAD){
			out[0] = '=';
			out++;
			out_len--;
		}
	}

	return out - start;
}

size_t xurl::xe_base64_decode(xe_base64_encoding encoding, xe_ptr vout, size_t out_len, xe_cptr vin, size_t in_len){
	xe_bptr out = (xe_bptr)out;
	xe_cbptr in = (xe_cbptr)vin;
	xe_bptr start = out;
	byte decoded[4];
	size_t lens[] = {0, 1, 1, 2, 3};

	while(in_len){
		for(uint i = 0; i < 4; i++)
			decoded[i] = i < in_len ? base64_decode[in[i]] : 0;
		out[0] = (decoded[0] << 2) | (decoded[1] >> 4);
		out[1] = (decoded[1] << 4) | (decoded[2] >> 2);
		out[2] = (decoded[2] << 6) | decoded[3];

		if(in_len > 4){
			in += 4;
			in_len -= 4;
			out += 3;
			out_len -= 3;
		}else{
			if(encoding == XE_BASE64_PAD || encoding == XE_BASE64_URL_PAD){
				while(in_len && in[in_len - 1] == '=')
					in_len--;
			}

			out += lens[in_len];

			break;
		}
	}

	return out - start;
}

byte xurl::xe_digit_to_int(char c){
	return c - '0';
}

bool xurl::xe_char_is_digit(char c){
	return xe_digit_to_int(c) < 10;
}

byte xurl::xe_hex_to_int(char c){
	return hex_decode[c];
}

bool xurl::xe_char_is_hex(char c){
	return xe_hex_to_int(c) < 0x10;
}